
# Types

## Overview

A user-defined `type` is written using the same **name `:` kind `=` value** syntax as everything in Cpp2. The type's "value" is a `{}`-enclosed body containing more declarations.

In a `type`, data members are private by default, and functions and nested types are public by default. To explicitly declare a type scope declaration `public`, `protected`, or `private`, write that keyword at the beginning of the declaration.

``` cpp title="Example: Writing a simple type"
mytype: type =
{
    // data members are private by default
    x: std::string;

    // functions are public by default
    protected f: (this) = { do_something_with(x); }

    // ...
}
```

## `this` — Parameters

The `this` parameter is explicit, and has special sauce:

- `this` is a synonym for the current object (not a pointer).
- Inside a type scope function, writing `this.` before a member name is optional.
- `this` defaults to the current type.
- `this`'s parameter passing style declares what kind of function you're writing. For example, `(in this)` (or just `(this)` since `in` is the default as usual) clearly means a `const` member function because `in` always implies constness; `(inout this)` means a non-const member function; `(move this)` expresses and emits a Cpp1 `&&`-qualified member function; and so on.
For example, here is how to write read-only member function named `print` that takes a read-only string value and prints this object's data value and the string message:

``` cpp title="Example: this"
mytype: type = {
    data: i32;   // some data member (private by default)

    print: (this, msg: std::string) = {
        std::cout << data << msg;
                 // "data" is shorthand for "this.data"
    }

    // ...
}
```

## `this` — Inheritance

Base types are written as members named this. For example, just as a type could write a data member as `data: string = "xyzzy";`, which is pronounced "`data` is a `string` defined as having the default value `"xyzzy"`, a base type is written as `this: Shape = (default, values);`, which is pronounced "`this` is a `Shape` defined as having these default values."

> Cpp2 syntax has no separate base list or separate member initializer list.

Because base and member subobjects are all declared in the same place (the type body) and initialized in the same place (an `operator=` function body), they can be written in any order, including interleaved, and are still guaranteed to be safely initialized in declared order. This means that in Cpp2 you can declare a data member object before a base subobject, so that it naturally outlives the base subobject.

> Cpp2 code doesn't need workarounds like Boost's `base_from_member`, because all of the motivating examples for that can be written directly. See my comments on [cppfront issue #334](https://github.com/hsutter/cppfront/issues/334) for details.

## `virtual`, `override`, and `final` — Virtual functions

Virtual functions are written by specifying exactly one of `virtual`, `override`, or `final` on the `this` parameter. A pure virtual function is a function with a `virtual this` parameter and no body. For example:

``` cpp title="Example: Virtual functions"
abstract_base: type
= {
    //  A pure virtual function: virtual + no body
    print: (virtual this, msg: std::string);

    // ...
}

derived: type
= {
    //  'this' is-an 'abstract_base'
    this: abstract_base;

    //  Explicit override
    print: (override this, msg: std::string);

    // ...
}
```

## `operator=` — Construction, assignment, and destruction

All value operations are spelled `operator=`, including construction, assignment, and destruction. All default to memberwise semantics and safe "explicit" by default. A special `that` parameter makes writing copy/move/conversion in particular simpler and safer. For details, see [Design note: operator=, this & that](https://github.com/hsutter/cppfront/wiki/Cpp2:-operator=,-this-&-that). Briefly summarizing here:

- The only special function every type must have is the destructor. If you don't write it by hand, a public nonvirtual destructor is generated by default.

- If no `operator=` functions are written by hand, a public default constructor is generated by default.

- All other `operator=` functions are explicitly written, either by hand or by opting into applying a metafunction (see below).

> Because generated functions are always opt-in, you can never get a generated function that's wrong for your type, and so Cpp2 doesn’t need to support "=delete" for the purpose of suppressing unwanted generated functions.

- The most general form of `operator=` is `operator=: (out this, that)`. It works as a unified general {copy, move} x { constructor, assignment } operator, and generates all of four of those in the lowered Cpp1 code if you didn't write a more specific one yourself (see design note above for details).

- All copy/move/comparison operator= functions are memberwise by default in Cpp2, including memberwise construction and assignment when you write them yourself.

- All conversion `operator=` functions are safely "explicit" by default. To opt into an implicit conversion, write the `implicit` qualifier on the `this` parameter.

- All functions can have a `that` parameter which is just like `this` (knows it's the current type, can be passed in all the usual ways, etc.) but refers to some other object of this type rather than the current object.

## `operator<=>` — Unified comparisons

Most of Cpp2's `operator<=>` has already been merged into ISO C++, except for allowing chained comparisons. In Cpp2, comparisons can be safely chained, and always have the mathematically sound transitive meaning or else are rejected at compile time:

- **Valid chains: All `<`/`<=`, all `>`/`>=`, or all `==`.** All mathematically sound and safe chains like `a <= b < c` are supported, with efficient single evaluation of each term. They are "sound" because they are transitive; these chains imply a relationship between `a` and `c` (in this case, the chain implies that `a <= c` is also true).

- **Invalid chains: Everything else.** Nonsense chains like `a >= b < c` and `a != b != c` are compile time errors. They are "nonsense" because they are non-transitive; these chains do not imply any relationship between `a` and `c`.

For details, see [P0515 "Consistent comparison" section 3.3](https://wg21.link/p0515) and [P0893 "Chaining comparisons"](https://wg21.link/p0893).

